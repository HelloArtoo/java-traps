package com.artoo.java_traps.demos;

public class Count {

	/**
	 * @param args
	 */
	public static void main(String[] args) {

		/**
		 * 这个循环只有在循环索引 f 比(float)(START + 50)小的情况下才运行。在将一个 int与一个 float
		 * 进行比较时,会自动执行从 int 到 float 的提升。遗憾的是,这种提升是会导致精度丢失的三种拓宽原始类型转换的一种[。(另外两个是从
		 * long 到 float 和从 long 到 double。) f 的初始值太大了,以至于在对其加上 50,然后将结果转型为 float
		 * 时,所产生的数值等于直接将 f 转换成 float 的数值。换句话说,(float)2000000000
		 * ==2000000050,因此表达式 f < START + 50
		 * 即使是在循环体第一次执行之前就是false,所以,循环体也就永远的不到机会去运行。
		 */
		// 输出什么？
		final int START = 2000000000;
		int count = 0;
		for (float f = START; f < START + 50; f++)
			// 2,000,000,050 与 2,000,000,000 有相同的 float，不会小于
			count++;
		System.out.println(count); // 0
		System.out.println((float) START == START + 50); // true

		/**
		 * 如果不使用计算机, 你如何才能知道 2,000,000,050 与 2,000,000,000 有相同的 float
		 * 表示呢?关键是要观察到 2,000,000,000 有 10 个因子都是 2:它是一个 2 乘以 9 个 10,而每个 10 都是
		 * 5×2。这意味着 2,000,000,000 的二进制表示是以 10 个 0 结尾的。50 的二进制表示只需要 6 位,所以将 50 加到
		 * 2,000,000,000 上不会对右边 6 位之外的其他为产生影响。特别是,从右边数过来的第 7 位和第 8 位仍旧是 0。提升这个
		 * 31 位的 int 到具有 24 位精度的 float 会在第 7 位和第 8 位之间四舍五入,从而直接丢弃最右边的 7 位。而最右边的
		 * 6 位是 2,000,000,000 与 2,000,000,050 位以不同之处,因此它们的 float 表示是相同 的。
		 * 
		 * 
		 * 不要使用浮点数作为循环索引,因为它会导致无法预测的行为。如果你在循环体内需要一个浮点数,那么请使用 int 或 long 循环索引,
		 * 并将其转换为 float 或 double。 在将一个 int 或 long 转换成一个 float 或
		 * double时,你可能会丢失精度,但是至少它不会影响到循环本身。当你使用浮点数时, 要使用 double 而不是 float,除非你肯定
		 * float 提供了足够的精度,并且存在强制性的性能需求迫使你使用 float。适合使用 float 而不是 double
		 * 的时刻是非常非常少的。
		 */

	}

}
