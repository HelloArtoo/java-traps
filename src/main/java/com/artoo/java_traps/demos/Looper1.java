package com.artoo.java_traps.demos;

public class Looper1 {

	/**
	 * 什么样的声明能够让下面的循环变成一个无限循环？
	 * 
	 * <pre>
	 * while (i == i + 1) {
	 * }
	 * </pre>
	 * 
	 * @param args
	 */
	public static void main(String[] args) {
		/**
		 * 正如我们在学校里面学到的,无穷大加 1 还是无穷大。如果 i在循环开始之前被初始化为无穷大, 那么终止条件测试(i == i +
		 * 1)就会被计算为 true,从而使循环永远都不会终止。
		 * 
		 * 这样做之所以可以起作用,是因为一个浮点数值越大,它和其后继数值之间的间隔就越大。
		 * 浮点数的这种分布是用固定数量的有效位来表示它们的必然结果。对一个足够大的浮点数加 1 不会改变它的值, 因为 1
		 * 是不足以“填补它与其后继者之间的空隙”
		 * 
		 * 浮点数操作返回的是最接近其精确的数学结果的浮点数值。一旦毗邻的浮点数值之间的距离大于 2, 那么对其中的一个浮点数值加 1
		 * 将不会产生任何效果,因为其结果没有达到两个数值之间的一半。 对于 float 类型,加 1 不会产生任何效果的最小级数是 225,即
		 * 33,554,432; 而对于 double 类型,最小级数是 254,大约是 1.8 × 1016。 毗邻的浮点数值之间的距离被称为一个
		 * ulp,它是“最小单位(unit in the lastplace)”的首字母缩写词。 在 5.0 版中,引入了 Math.ulp
		 * 方法来计算 float或 double 数值的 ulp。总之,用一个 double 或一个 float
		 * 数值来表示无穷大是可以的。大多数人在第一次听到这句话时,多少都会有一点吃惊, 可能是因为我们无法用任何整数类型第二点,
		 * 来表示无穷大的原因。将一个很小的浮点数加到一个很大的浮点数上时,
		 * 将不会改变大的浮点数的值。这过于违背直觉了,因为对实际的数字来说这是不成立的。 我们应该记住二进制浮点算术只是对实际算术的一种近似。
		 */

		// i 填写什么能使i = i +1 为true
		// 答案
		double i = 1.0 / 0.0;// 或者
		/** 其实这个答案也是可以的：float i = 2000000000;参考Count.java，低位被舍弃 **/
		// Double.POSITIVE_INFINITY(public static final double POSITIVE_INFINITY
		// = 1.0 / 0.0;)
		while (i == i + 1) {

		}

	}

}
