package com.artoo.java_traps.demos;

/**
 * 给出变量x和i的申明，使得 x += i;语句合法，而x = x + i; 不合法。
 * 
 * @author Administrator
 * 
 */
public class Tweedledum {

	/**
	 * <pre>
	 * 这两个表达式都被称为赋值表达式。第二条语句使用的是简单赋值操作符(=),而第一条语句使用的是复合赋值操作符 
	 * (复合赋值操作符包括 +=、-=、*=、/=、%=、<<=、>>=、>>>=、&=、^=和|=) 。
	 *  Java 语言规范中讲到,复合赋值 E1 op= E2 等价于简单赋值 E1 = (T)((E1)op(E2)),
	 *  其中 T 是 E1 的类型,除非 E1 只被计算一次。换句话说, 复合赋值表达式自动地将它们所执行的计算的结果转型为其左侧变量的类型。
	 *  如果结果的类型与该变量的类型相同, 那么这个转型不会造成任何影响。然而,如果结果的类型比该变量的类型要宽,那么复合赋值操作符将悄悄地执行一个窄化原始类型转换。
	 *  因此,我们有很好的理由去解释为什么在尝试着执行等价的简单赋值可能会产生一个编译错误。复合赋值编译将不会产生任何错误:
	 *     x += i; // 包含了一个隐藏的转型!
	 * 
	 *     你可能期望 x 的值在这条语句执行之后是 123,456,但是并非如此,它的值是-7,616。int 类型的数值 123456 对于 short 来说太大了。自动产生的转型悄悄地把 int 数值的高两位给截掉了。
	 * 	这也许就不是你想要的了。相对应的简单赋值是非法的,因为它试图将 int 数值赋值给 short 变量,它需要一个显式的转型:
	 *     x = x + i; // 不要编译——“可能会丢掉精度”
	 * 
	 * </pre>
	 * 
	 * @param args
	 */
	public static void main(String[] args) {
		int i = 123456;
		short x = 0;
		x += i;
		/**
		 * Exception in thread "main" java.lang.Error: Unresolved compilation
		 * problem: Type mismatch: cannot convert from int to short
		 * 
		 * at com.artoo.java_traps.demos.Tweedledum.main(Tweedledum.java:18)
		 */
		// x = x + i; // 此处异常

		/**
		 * 总结：复合赋值表达式可能是很危险的。为了避免这种令人不快的突袭,请不要将复合赋值操作符作用于 byte、short 或 char
		 * 类型的变量上。在将复合赋值操作符作用于 int 类型的变量上时, 要确保表达式右侧不是 long、float或 double
		 * 类型。在将复合赋值操作符作用于 float 类型的变量上时,要确保表达式右侧不是 double
		 * 类型。这些规则足以防止编译器产生危险的窄化转型。
		 */

		// -----------------------------------------------------------------------------------
		// 与上面的谜题相反，请给出变量x和i的申明，使得 x += i;语句不合法法，而x = x + i; 合法。
		Object a = "Hello";
		String b = "Word";
		a = a + b;
		/**
		 * 复合赋值操作符要求两个操作数都是原始类型的,例如 int,或包装了的原始类型,例如
		 * Integer,但是有一个例外:如果在+=操作符左侧的操作数是
		 * String类型的,那么它允许右侧的操作数是任意类型,在这种情况下,该操作符执行的是字符串连接操作
		 * 。简单赋值操作符(=)允许其左侧的是对象引用类型
		 * ,这就显得要宽松许多了:你可以使用它们来表示任何你想要表示的内容,只要表达式的右侧与左侧的变量是赋值兼容的即可。
		 */
		 //a += b; //编译报错

	}

}
